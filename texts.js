'use strict';

module.exports = {
  CDMA: {
    heading: 'Виділення сигналу зі спільного каналу з шумом',
    introPart: '<p>Основним запитанням є: як з такого незрозумілого на перший погляд потоку інформації виділити необхідну початкову інформацію? Відповидь доволі проста: псевдовипадкові послідовності що використовуються для кодування мають гарні автокореляційні та погані кросс-корелційні властивості. Гарні автокореляційні властивості - тут мається на увазі що при перевірці на схожість однієї й тієї ж послідовності, при цьому одну з них покроково циклично здвигають для наступного циклу перевірки, отримаємо один пік зі значенням N де всі елементи видповидають одне одному (нульовий здвиг) та значення 1 / N для всіх інших перевірок, де N - довжина послідовності. Погані кросскорелятивні властивості - означає що при перевірці на схожість однієї послідовності з іншими послідовностями не має бути ніяких піків.</p><p>Таким чином, все що нам потрібно зробити - це підрахувати кореляцію сигналу в спільному каналі з відповідною псевдовипадковою послідовністю. Але не просто з псевдовипадковою послідовністю, а промодульваною нею несучу (частота якої дорівнює частоті несучої сигналу в спільному каналі). Далі результат пропускається через низькочастотний фільтр щоб позбутися від несучої і отримати огинаючу. Результати кореляцій зображені на графіку 12 та 13.</p><p>Перший сигнал <pre>[0, 1, 0, 1, 0]</pre> Другий сигнал <pre>[1, 0, 1, 0, 1]</pre></p> Видповідно додатній пік декодується в зворотньому напрямку як 0, від\'ємний як 1. Як бачимо навіть в каналі з шумом кореляційні піки чітко виділяються на фоні бокових пелюсток.',
    signalWithNoiseInCommonChannelCaption: 'Граф. 11, Сигнал у спільному каналі з шумом',
    firstSignalCorrelationCapture: 'Граф. 12, Кореляція спільного сигналу з кодом першого сигналу',
    secondSignalCorrelationCapture: 'Граф. 13, Кореляція спільного сигналу з кодом другого сигналу'
  },
  commonChannel: {
    heading: 'Сигнали в спільному каналі',
    introPart: 'Після того як сигнали нанесені на несучу вони потрапляють в спільний канал передачі (після виходу з антени передавача). Під спільним каналом мається на увазі спільна частотна смуга сигналів. Все що з ними відбувається в даному випадку - це накладання інтенсивностей (простими словами сигнали просто сумуються). На графіку 8 зображено сигнал в спільному каналі після накладання двох сигналів.',
    firstSignalOnCarrierCapture: 'Граф. 6, Перший закодований сигнал нанесениий на несучу',
    secondSignalOnCarrierCapture: 'Граф. 7, Другий закодований сигнал нанесениий на несучу',
    signalInCommonChannelCaption: 'Граф. 8, Сигнал у спільному каналі'

  },
  commonChannelWithNoise: {
    heading: 'Шум в спільному каналі',
    introPart: 'Оскільки в будь-якому середовищі неможливо утримувати канал передачі даних ізольованим від зовнішніх чинників та шумів, в спільний канал потрапляють шуми та інши небажані сигнали. Сигнал в спільному каналі набуває вигляду який зображено на графіку 10. Ми припускаємо в даній роботі що шум - це сигнал довільної інтенсивності в довільний момент часу, який просто сумується з інформаційнийм сигналом по інтенсивності.',
    signalInCommonChannelCaption: 'Граф. 9, Сигнал у спільному каналі',
    signalWithNoiseInCommonChannelCaption: 'Граф. 10, Сигнал у спільному каналі з шумом'
  },
  sequenceGuessing: {
    heading: 'Кореляція сигналу з випадковою послідовністю',
    introPart: 'Вам пропонується підібрати зворотній зв\'язок в регістрі зсуву таким чином щоб отримати чітку кореляцію. Необхідно підібрати два набора тригерів в зворотеьому зв\'язку якими закодовано два інформаційних сигнали. Введіть отримані сигнали нижче. (Пам\'ятайте, що додатній пік декодується як 0, від\'ємний як 1).',
    sequenceInitButton: 'Ініціювати послідовність',
    inputSignals: 'Ввдедіть отримані сигнали нижче:',
    commonChannelCaption: 'Граф. 13, сигнал в спільному каналі'
  },
  signalOnCarrier: {
    heading: 'Модуляція несучої',
    introPart: '<p>Після того як сигнал було закодовано методом прямої послідовності його необхідно підготовити для передачі в реальних системах зв\'язку. Під цим позуміється нанесення на високочастотну несучу що дозволить передавати на далекі відстані (низькочастотні сигнали не здатні поширюватись на далекі відстані через низький рівень енергії).</p><p>Для того щоб нанести сигнал на несучу його необхідно трансформувати. Трансформація полягає перетворенні двійкової одиниці в -1, а двійкового нуля в 1. Таким чином двійковий сигнал набуває більш фізичного змісту, бо його можна імітувати напругою відповідно в 1 та -1 Вольт. Але основна ідея в тому що при нанесенні двійкового сигналу на синусоїду в термінах "1, 0" ми отримаємо або синусоїду або нічого (нанесення сигналу на синусоїду використовує операціє множення), а в термінах "-1, 1" ми отримаємо або пряму або інвертовану синусоїду. В місцях де -1 чергується з 1 можна побачити стрибок фази (пряма синусоїда міняє інвертовану і т.д.). Отриманий сигнал називається BPSK (binary phase shifting key) сигнал. BPSK - найпростіша форма фазової маніпуляції сигналу, але в даному найпростіша значить ще й найточніша, що добре складується з сигналами GPS - об\'єм інформаційного повідомлення невеликий але має бути точно визначеним на детекторі.</p>',
    signalWithSequenceCapture: 'Граф. 4, Закодований сигнал',
    aboutCarrying: 'На принциповій схемі зображено які компоненти приймають участь в моделюванні несучої: це результуючий сигнал після додавання по модулю два псевдовипадкової послідовності з кожним бітом інформаційної послідовності та згенерована синусоїда з генератора несучої. Як правило частота несучої набагато більша за частоту псевдошумового сигналу, для прикладу в GPS частота несучої 1.5 ГГц а сигналу 1 МГц7. В даній роботі взято відношення частот таким чином щоб в один біт інформаційної послідовності потрапляв рівно один період несучої. На графіку 6 зображено Промодульовану псевдовипадковим сигналом несучу. Можна використати зумер внизу графіку щоб детально роздивитись фазові переходи.',
    carrierCaption: 'Граф. 5, Несуча, гармонічний сигнал',
    signalOnCarrierCapture: 'Граф. 6, Промодульована несуча, BPSK сигнал'
  },
  signalWithSequence: {
    heading: 'Кодування сигналу методом прямої послідовності',
    introPart: '<p>Кодування в системах зв\'язку використовується, як правило, по 2 причинам: <ul><li>завадостійкість</li><li>підвищення надійності даних (одмеження доступу до інформації)</li></ul> Це чи не найоголовніші чинники в сучасних комунікаційних технологіях, тому і кодування є важлівою темою.</p><p>Існує багато типів кодування сигналу, але оскільки наша робота стосується лише навігаційних сигналів GPS (та CMDA каналів зв\'язку) то ми обмежемось лише кодуванням що стосується цієї роботи, а саме кодування псевдовипадковою послідовністю та утворення сигналів з уширеним спектром.</p><p>Spread Spectrum (SS) системи використовувалися винятково для військових та наукових цілей. Властивості, що робили ці системи привабливим для військових, роблять їх ідеальними і для цивільного використання. Це стійкість до перешкод і навмисного втручання, труднощі у виявленні і перехопленні, а також можливість закриття інформації. Завдяки розширенню спектра сигналу помітно зменшується вплив електромагнітних перешкод на цілісність сигналу (при тривалому впливі). Завада, що з\'являється в смузі частот SS сигналу, може вразити тільки дуже маленьку частину всієї смуги, а тому, що переданий сигнал розподілений на весь спектр, він буде надійно відновлений у приймачі. Розширення спектра сигналу забезпечує розосередження енергії сигналу в межах великої смуги частот, знижує щільність потужності в будь-якій частині спектра, що дозволяє зменшити сигнал нижче рівня шуму. Стандартний вузькосмуговий приймач не може розпізнати за шумами сигнали SS, але той може бути прийнятий спеціальним SS приймачем. Вузькосмугові сигнали і перешкоди знешкоджуються в процесі обробки. </p><p> Є декілька методів надлишкового уширення спектру сигналу, в даній роботі розглянуто уширення спектру методом прямої послідовності. Це метод що перетворює початковий інформаційний сигнал в псевдовипадкову шумову послідовність, яка далі використовується для модуляції несучої. Отже детальніше про технологію реалізації. Візьмемо звичайний двійковий сигнал що зображено на рис. 1<pre>[0, 1, 0, 1, 0]</pre></p>',
    signalCapture: 'Граф. 1, Бітовий інфромаційний сигнал',
    aboutPRNCode: '<p>У якості модулюючих послідовностей найбільше поширення, у наслідок простоти формування і задовільних кореляційних властивостей, одержали М-послідовності, або послідовності максимального періоду регістру зсуву. Основні властивості М-послідовностей:</p><ul><li>М-послідовність є періодичною, з періодом, що складається з N - імпульсів (символів);</li><liбічні викиди періодичної КФ дорівнюють - 1/N;</li><li>імпульси різного виду зустрічаються в періоді однакове число разів, тобто розподілені рівномірно;<li>формування М-послідовностей відбувається за допомогою лінійних перемикаючих схем, на базі регістрів зсуву</li></ul><p>Принцип роботи лінійного регістру зсуву зі зворотнім зв\'язком полягає в наступному: всі тригери в ланцюжку ініціалізуються 1. Розраховується максимальна довжина послідовності що може бути згенерована даним регістром за формулою N = 2 ^ n - 1, де n -кількість тригерів в регістрі. Максімальна довжина на 1 менша через те що комбінація з усіма нулями є виключною і приводить до зациклення регістру. Максимальна довжина послідовності дорівнює кількості тактів, що небохідні для отримання послідовності. Одним тактом називається циклічний зсув данних в регістрі зсуву. Кожен тактовий імпульс визиває зміну стану тригеру на виході. Стан кожного тригеру на виході дорівнює стану цього тригеру на вході для попереднього такту. Кінцевий результат знімається з виходу останнього тригера в ланцюгу.</p><p>Зворотній звя\'зок являє собою суматор по модулю два (так званий xor, виключне або), на вхід якого подаються дані з виходу тригерів що підключено до зворотнього звязку. Також до зворотнього зв\'язку входить останній тригер з регістру. В інтерактивному режимі можна прослідкувати за утворенням псевдовипадкової послідовності на баз лінійного регістру зсуву довжиною 5 зі зворотнім звязком 5 та 3</p>',
    PRNCapture: 'Граф. 2, Бітова псевдовипадкова послідовність',
    nextStep: 'Наступний такт',
    aboutMixingSignalWithPRN: '<p>Як видно з графіку номер 2 утворена послідовніть містить 31 біт інформації, що як і було сказано раніше = 2 ^ 5 - 1. Наступний крок - це змішування отриманої послідовності з інформаційним сигналом. Відношення частот для GPS сигналів складає 50 Гц інформаційний сигнал та 1023КГц, при цьому довжина послідовності що використовується в GPS = 1023 (10-розрядний регістр зсуву). Обрахувавши просту пропорцію можна визначити що в один біт інформаційної послідовності має поміститись 20 псевдовипадкових послідовностей довжиною 1023. В нашому випадку для простоти обрахунків та поліпшення розуміння ми кладемо що в один інформаційний біт має потрапити одна псевдовипадкова послідовність довжиною 31. Накладання псевдовипадкової послідовності на іфнормаційну відбуваєьбся знайомим вже нам додаванням по модулю два (xor-ом). Таким чином  на виході маємо інформаційну послідовність довжиною 5 (довжина сигналу) * 31 (довжина послідовності) = 155 біт. Результуюча послідовність складається з псевдовипадкових послідовностей, але прямих та інвертованих, що з\'явились шляхом додавання по модулю 2 з одиничним та нульовим інформаційними бітами відповідно. Результуючий сигнал зображено на графіку 3</p>',
    signalWithSequenceCapture: 'Граф. 3, Бітовий інформаційний сигнал нанесений на пвшп',
    principalSchemaCapture: 'Рис. 1, принципова схема',
    aboutPrincipalSchema: 'На принциповій схемі генерації сигналу підсвічено які саме компоненти відіграють роль в утворенні зашумленого сигналу з уширеним спектром. Наступним кроком є модуляція несучої створеним шумовийм сигналом'
  },
  commonTexts: {
    mainHeader: 'Кореляційний прийом сигналу',
    nextButton: 'Далі',
    prevButton: 'Назад',
    finishButton: 'Завершити',
    finished: 'Завершено'
  },
  commonErrors: {
    thereIsNoSuchUser: 'Вибачте, в системі не існує такого кориcтувача',
    invalidPassword: 'Ви ввели невірний пароль',
    accessDenied: 'Доступ заборонено'
  },
  loginPage: {
    headerText: 'Ваші дані',
    groupName: 'Введіть, будь ласка, назву групи (Її має сказати керівник)',
    firstName: 'Введіть, будь ласка, своє ім\'я',
    lastName: 'Введіть, будь ласка, своє прізвище',
    userPassword: 'Введіть, будь ласка, пароль',
    start: 'Розпочати'
  },
  adminTable: {
    selectTheGroup: 'Оберіть группу',
    firstName: 'Ім\'я',
    lastName: 'Прізвище',
    isFinished: 'Чи виконано',
    done: 'Виконано',
    inProgress: 'В процессі',
    deleteGroup: 'Видалити групу',
    deleteUser: 'Видалити користувача',
    delete: 'Видалити'
  }
};